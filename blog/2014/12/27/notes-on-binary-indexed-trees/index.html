
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Notes on Binary Indexed Trees (Fenwick Trees) - Mango Ice Cream</title>
  <meta name="author" content="Kevin Pan">

  
  <meta name="description" content="A brief overview of what a Binary Indexed Tree, or Fenwick Tree is. Quickly and intuitively learn how this data structure works and how it's &hellip;">
  
  <meta name="keywords" content="">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://kevinpan.me/blog/2014/12/27/notes-on-binary-indexed-trees">
  <link href="/favicon.png" rel="icon">
  <link href='http://fonts.googleapis.com/css?family=Quicksand:300,400' rel='stylesheet' type='text/css'>
  <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300' rel='stylesheet' type='text/css'>
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/custom.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Mango Ice Cream" type="application/atom+xml">
  <script src="/js/jquery.js"></script>
  <script src="/js/bootstrap-collapse.js"></script>
  <script src="/js/modernizr-2.0.js"></script>
  <script src="/js/octopress.js" type="text/javascript"></script>
  <script src="/js/application.js"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<!-- mathjax config similar to math.stackexchange -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ['$', '$'] ],
    displayMath: [ ['$$', '$$']],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  messageStyle: "none",
  "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
});
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML" type="text/javascript"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-57905192-1', 'auto');
  ga('send', 'pageview');

</script>
<body   >
  <div class="navbar navbar-inverse navbar-static-top">
    <div class="navbar-inner">
      <div class="container">
        <a class="btn btn-navbar" data-toggle="collapse" data-target=".navbar-responsive-collapse">
          <span class="fui-menu-24"></span>
        </a>
        <div class="nav-collapse collapse navbar-responsive-collapse" style="height:0;">
          <ul class="nav">
    
        <li ><a href="/">Home</a></li>
    
        <li ><a href="/blog/archives">Archives</a></li>
    
        <li ><a href="http://www.kevinpan.ca/about">About Me</a></li>
    
</ul>

<ul class="nav pull-right">
    
    
    
    
    
    
    

    
</ul>

        </div>
      </div>
    </div>
  </div>
  <div class="container" id="main">
      <div class="row-fluid">
        <div id="content">
          <div>
<article class="hentry" role="article">
  

  <header>
  <div class="jumbotron">
    Notes on Binary Indexed Trees (Fenwick Trees)
	<h5>




<i class="icon-calendar-empty"></i> <time class='entry-date' datetime='2014-12-27T13:52:31-08:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>27</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>1:52 pm</span></time></h5>
  </div>
</header>
  <div class="row-fluid">
    <div class="span12">
      <p>A binary indexed tree came up in one of the Hackerrank challenges I was working on recently. This is the first time I’ve ever heard of this data structure and I was interested in learning more. I found this TopCoder <a href="http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=binaryIndexedTrees">article</a> on binary indexed trees a particularly useful resource and below is a concise summary of what I’ve learnt.</p>

<p>Suppose we have a size-$n$ array of values. If we wanted to find the summation of all values between two indices, we would need to iterate through the entire interval while maintaining a summation variable. If we then wanted to make $m$ such queries, the time complexity of the whole operation would be $O(mn)$. A binary indexed tree allows us to do this in $O(m\log\ n)$ time. The one trade off is that it takes longer to construct the initial data structure ($O(n \log\ n)$ time instead of $O(n)$ time, which is if we had used an array).</p>

<p>Internally, we will still be using a size-$n$ array to represent the tree. The <strong>main idea</strong> of a binary indexed tree is that indices that are a power of 2 will have the cumulative frequency of all indices before, including itself. Indices that are half way between two indices that are a power of 2 will have the cumulative frequency of all indices before it starting from, but not including, the lower power of 2 index. This pattern continues down a hierarchical structure until you reach an odd index which will only have the frequency of itself. This can be visualized with the following diagram from the aforementioned article:</p>

<p><img align="right" src="http://community.topcoder.com/i/education/binaryIndexedTrees/bitval.gif" alt="Binary indexed tree visualization" /></p>

<p>Another way to put this is that each index $i$ in a binary indexed tree stores the sum of all frequencies of the indices in the range $(i - 2^r, i]$ where $r$ represents the rightmost set bit of $i$. From this definition, it is easier to tell that an index that is a power of 2 will have the sum of all frequencies of the indices before it while an odd index will just contain the frequency of itself.</p>

<p><strong>Note:</strong> for a binary indexed tree, internally, the starting index is $1$ and not $0$</p>

<h2 id="isolating-the-rightmost-set-bit-of-a-number">Isolating the rightmost set bit of a number</h2>

<p>Given the structure of the binary indexed tree, many of its operations will often need to find and isolate the rightmost set bit of a number. As such, we need to be able to do this efficiently.</p>

<p>Any nonzero binary number can be represented in the form $(a)(1)(0..0)$, where $a$ is the rest of the binary number to the left of the rightmost set bit. To isolate the rightmost set bit of one such number (call it $x$), we need to use its two’s complement representation.</p>

<p>To get the two’s complement representation of a number, all we need to do is invert every bit and add $1$ to the result. So if $x = (a)(1)(0..0)$, then the two’s complement representation of $x$ will be $(a^{-})(1)(0..0)$. Bitwise ANDing the two binary numbers together will then result in $(0..0)(1)(0..0)$. This is exactly what we want!</p>

<p>Most computers in the world represent negative integers using two’s complement so all we need to do in code is <code>x &amp; -x</code>.</p>

<h2 id="finding-the-cumulative-frequency-for-a-particular-index">Finding the cumulative frequency for a particular index</h2>

<p>Suppose we want to find the cumulative frequency from index $1$ to a particular index $x$. We know that at index $x$, the tree stores the cumulative frequency of the indices in the interval $(x - 2^r, x]$.</p>

<p>So to find the cumulative frequency of the indices in $[1, x]$, we first add <code>binary_index_tree[x]</code> to a summation variable and subtract the rightmost set bit of $x$ from itself. Now if we query for <code>binary_index_tree[x]</code> again, we get the cumulative frequency of all indices between $(x - 2^r - 2^{r_1}, x - 2^r]$. When we add the new <code>binary_index_tree[x]</code> to the summation variable, we get the cumulative frequencies of indices between $(x - 2^r - 2^{r_1}, x]$. We keep repeating this process until the left endpoint of the interval becomes $0$, which is when we have our answer.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kt">int</span> <span class="nf">read</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class="line">    <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">sum</span> <span class="o">+=</span> <span class="n">binary_index_tree</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class="line">        <span class="n">i</span> <span class="o">-=</span> <span class="o">(</span><span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line">    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since the max index you can query for is $n$ (which is the total size of the data set) and it can have a maximum of $\log\ n$ set bits, the <code>read</code> function’s time complexity is $O(\log\ n)$.</p>

<h2 id="changing-frequency-of-a-particular-index">Changing frequency of a particular index</h2>

<p>To change a frequency at a particular index $x$, we also need to change the values of all indices that contain it. All such indices will be greater than $x$.</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="java"><span class="line"><span class="kt">void</span> <span class="nf">update</span> <span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">    <span class="k">while</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
</span><span class="line">        <span class="n">binary_index_tree</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">+=</span> <span class="n">val</span><span class="o">;</span>
</span><span class="line">        <span class="n">idx</span> <span class="o">+=</span> <span class="o">(</span><span class="n">idx</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">idx</span><span class="o">);</span>
</span><span class="line">    <span class="o">}</span>
</span><span class="line"><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>Since we are iterating to $n$ and we’re adding the rightmost set bit of the current index to itself at each iteration, the <code>update</code> function’s time complexity is also $O(\log\ n)$.</p>

<h2 id="other-operations">Other operations</h2>

<p>I’ve only written about the two most basic operations you can do with a binary indexed tree. If you would like to learn more, the TopCoder article I mentioned above provides indepth explanations into many others.</p>

    </div>
  </div>



  <footer>
    <hr>
    
    <div class="row-fluid">
      
      <div class="span6">
        <p class="meta">
        
        


        </p>
      </div>
      
      <div class="span6 social-sharing">
        <div class="sharing">
  <div class="addthis_toolbox addthis_default_style ">
  
  
  <a class="addthis_button_tweet"></a>
  
  
  <a class="addthis_counter addthis_pill_style"></a>
  </div>
  <script type="text/javascript" src="http://s7.addthis.com/js/250/addthis_widget.js#pubid="></script>
</div>

      </div>
      
      
    </div>
    
    <div class="row-fluid">
      <div class="span12">
        <p class="meta">
          
            <a class="basic-alignment left" href="/blog/2014/12/23/hackerrank-challenge-median-when-in-doubt-use-stringbuilder/" title="Previous Post: Hackerrank Challenge: Median - when in doubt, use StringBuilder">&laquo; Hackerrank Challenge: Median - when in doubt, use StringBuilder</a>
          
          
            <a class="basic-alignment right" href="/blog/2014/12/31/bijective-numeration-and-length-restricted-character-permuations/" title="Next Post: Bijective numeration and length-restricted character permutations">Bijective numeration and length-restricted character permutations &raquo;</a>
          
        </p>
      </div>
    </div>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>



        </div>
      </div>
      <div class="row-fluid">
        <footer class="footer-page" role="contentinfo">
          <p>
  Copyright &copy; 2015 - Kevin Pan -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span> - Theme by <a href="http://alexgaribay.com">Alex Garibay</a>
</p>


        </footer>
      </div>
  </div>
  

<script type="text/javascript">
      var disqus_shortname = 'mangoicecream';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://kevinpan.me/blog/2014/12/27/notes-on-binary-indexed-trees/';
        var disqus_url = 'http://kevinpan.me/blog/2014/12/27/notes-on-binary-indexed-trees/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
